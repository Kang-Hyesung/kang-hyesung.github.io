---
title: "JAVA 에서 char 자료형 크기가 2바이트인 이유"
date: 2025-11-11 21:39 +0900
author: "hyesung"
description: "설명"
---
# 💡 자바에서 `char`는 왜 2바이트일까? — 유니코드와 서로게이트 페어 완전 이해하기

자바를 처음 배우다 보면 이런 의문이 생길 때가 있다.

> “자바에서 `char`는 왜 2비트(혹은 2바이트)일까?”
> “그럼 16비트로 표현 안 되는 이모지는 어떻게 저장돼?”
> “`String.length()`는 왜 이모지 하나인데 2가 나올까?”

## 이 글에서는 이런 궁금증을 완전히 정리해본다.

## 🔠 1. `char`는 2비트가 아니라 **2바이트(16비트)**

먼저 정확히 짚고 가자.
자바의 `char`는 **2비트(2 bits)** 가 아니라 **2바이트(2 bytes, 16 bits)** 다.

```java
System.out.println(Character.BYTES);  // 2
```

즉, `char`는 **항상 16비트 고정 크기**의 자료형이다.

---

## 🌍 2. 왜 16비트일까?

자바가 만들어질 당시(1995년), **유니코드(Unicode)** 는 “모든 문자를 16비트로 표현할 수 있다”는 가정하에 설계되었다.
그래서 자바는 국제화를 지원하기 위해 `char` 타입을 **16비트 유니코드 문자** 단위로 정의했다.

| 항목           | 내용          |
| ------------ | ----------- |
| 언어 설계 시기     | 1990년대 중반   |
| 당시 유니코드 크기   | 16비트        |
| 자바 `char` 크기 | 16비트 (2바이트) |
| 목적           | 전 세계 언어 지원  |

이 덕분에 자바는 초창기부터 한글, 일본어, 중국어 등을 안정적으로 표현할 수 있었다.

---

## 🧩 3. 그런데 지금의 유니코드는 16비트를 넘어간다

현재(유니코드 15.0 기준) 유니코드는 **21비트** 까지 확장되었다.
즉, 16비트로는 표현할 수 없는 문자들이 존재한다 — 바로 **이모지(😊, 🦄, 🐉)** 나 고대 문자들이다.

| 문자     | 코드 포인트  | 16비트로 표현 가능? |
| ------ | ------- | ------------ |
| `'A'`  | U+0041  | ✅ 가능         |
| `'가'`  | U+AC00  | ✅ 가능         |
| `'😊'` | U+1F60A | ❌ 불가능        |

---

## ⚙️ 4. 자바는 이 문제를 “서로게이트 페어(Surrogate Pair)”로 해결한다

자바의 `char`는 여전히 16비트지만,
16비트로 표현할 수 없는 문자를 저장할 때는 **`char` 두 개(=4바이트)** 를 사용한다.
이 두 개의 `char`가 합쳐져 하나의 문자를 이루는 구조다.

```java
String s = "😊";
System.out.println(s.length());      // 2
System.out.println(s.codePointCount(0, s.length())); // 1
```

* 내부적으로는 `char` 2개 사용 → `.length()` = 2
* 실제로는 문자 1개 → `.codePointCount()` = 1

이 방식을 **서로게이트 페어(surrogate pair)** 라고 부른다.

---

## 🚫 5. `😊`를 `char` 변수에 직접 담을 수는 없다

```java
char a = '😊';  // ❌ 컴파일 오류
```

이유는 `😊`의 코드포인트(U+1F60A)가 `char`의 표현 범위(0x0000 ~ 0xFFFF)를 초과하기 때문이다.

대신 다음과 같은 방법으로 처리할 수 있다 👇

### ✅ 방법 1. `String`으로 저장

```java
String s = "😊";
```

### ✅ 방법 2. `int`로 코드포인트를 직접 다루기

```java
int codePoint = 0x1F60A;
String s = new String(Character.toChars(codePoint));
```

### ✅ 방법 3. `char` 두 개(서로게이트 페어)로 접근하기

```java
String s = "😊";
char high = s.charAt(0); // '\uD83D'
char low  = s.charAt(1); // '\uDE0A'

System.out.printf("high: %04X, low: %04X\n", (int)high, (int)low);
// 출력: high: D83D, low: DE0A
```

```
String s = "A😊B";

┌──────┬────────────┬────────────┬──────┐
│  A   │  😊 (High)│   😊 (Low) │  B   │
│U+0041│ U+D83D     │ U+DE0A     │U+0042│
└──────┴────────────┴────────────┴──────┘
           ↑               ↑
        서로게이트 페어 (U+1F60A)

```

---

## 🧠 6. `String.length()`와 실제 문자 수의 차이

이모지처럼 서로게이트 페어로 구성된 문자가 문자열에 들어 있으면,
`String.length()`는 `char` 단위로 길이를 세기 때문에 **2**가 나온다.

```java
String s = "A😊B";
System.out.println(s.length());                    // 4 (A + 서로게이트2개 + B)
System.out.println(s.codePointCount(0, s.length())); // 3 (A, 😊, B)
```

| 메서드                               | 의미                      | `"😊"` 결과 |
| --------------------------------- | ----------------------- | --------- |
| `s.length()`                      | UTF-16 코드 유닛(`char`) 개수 | 2         |
| `s.codePointCount(0, s.length())` | 실제 유니코드 문자 수            | 1         |

---

## ✅ 7. 핵심 정리

| 항목                | 내용                             |
| ----------------- | ------------------------------ |
| `char` 크기         | 16비트 (2바이트)                    |
| `char` 표현 범위      | U+0000 ~ U+FFFF                |
| 이모지(😊 등)         | `char` 하나로 표현 불가               |
| 해결 방식             | 서로게이트 페어 (`char` 2개 사용)        |
| `String.length()` | 16비트 단위 수 (서로게이트 포함)           |
| 실제 문자 수           | `String.codePointCount()` 로 구함 |

---

## ✨ 마무리

요약하자면,

> 자바의 `char`는 유니코드 16비트 설계 철학의 유산이며,
> 현대의 이모지나 확장 문자들은 “서로게이트 페어”로 처리된다.
> 따라서 “문자 수”와 “문자열 길이”는 반드시 구분해서 이해해야 한다.

---

**👨‍💻 참고 메서드 정리**

```java
s.length();                        // char 개수
s.codePointCount(0, s.length());   // 실제 문자 수
s.codePointAt(i);                  // i번째 문자(유니코드 코드포인트)
Character.toChars(codePoint);      // 코드포인트 → char[] 변환
```

---

> 💬 *“이모지는 char 2개짜리 문자다.”*
>
> 다음에 누군가 자바에서 “😊를 char에 담을 수 있냐?” 묻는다면,
> 자신 있게 “**못 담아요. String에 담으세요.**” 라고 답하자 😄


