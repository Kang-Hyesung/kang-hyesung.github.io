---
title: 함수 호출, 메모리 관리, 그리고 가비지 컬렉션(GC)
date: 2025-12-21 21:37 +0900
author: hyesung
description: 메모리 구조와 매개변수 전달 방식, 그리고 가비지 컬렉션의 동작 원리
categories: JAVA
tags:
  - stack
  - heap
  - gc
  - CallbyValue
  - CallbyReference
---
## 1. 메모리 구조의 이해: Stack과 Heap

프로그램이 실행될 때 데이터 저장은 성격에 따라 **스택(Stack)** 과 **힙(Heap)** 두 가지 영역으로 나뉘어 관리된다.

### 1.1. 스택(Stack) 영역과 스택 프레임

스택은 메서드 호출과 연산의 흐름을 담당하는 메모리 영역이다.

* **스택 프레임(Stack Frame):** 함수가 호출될 때마다 생성되는 메모리 블록이다. 단순한 변수 저장소가 아니라 다음과 같은 체계적인 내부 구조를 가진다.
* **지역 변수 배열(Local Variable Array):** 매개변수(Parameter)와 메서드 내부의 지역 변수, `this` 참조 등이 저장된다.
* **피연산자 스택(Operand Stack):** 연산의 중간 결과값을 저장하는 임시 작업 공간이다.
* **프레임 데이터(Frame Data):** 리턴 주소(함수 종료 후 돌아갈 위치)와 상수 풀 참조 정보 등을 포함한다.


* **수명:** 함수가 종료(Return)되면 해당 프레임은 스택에서 즉시 제거(Pop)되며, 내부의 모든 데이터도 소멸한다.

### 1.2. 힙(Heap) 영역

힙은 프로그램 상에서 런타임에 생성되는 모든 **객체(Instance)** 와 **배열**이 저장되는 공간이다.

* **생성:** `new` 연산자를 사용하거나 배열을 선언할 때 할당된다.
* **접근:** 스택 영역에 있는 참조 변수가 힙 영역의 메모리 주소를 가지고 있으며, 이를 통해 데이터에 접근한다.
* **수명:** 함수 호출이 끝나도 즉시 사라지지 않으며, 가비지 컬렉터(GC)에 의해서만 제거된다.

---

## 2. 매개변수 전달 기법 (Parameter Passing)

함수 호출 시 데이터를 전달하는 방식은 변수의 자료형에 따라 구분된다.

### 2.1. Call by Value (값에 의한 호출)

* **대상:** `int`, `double`, `boolean` 등 기본 자료형(Primitive Type).
* **동작:** 변수가 가진 **값(Value)** 자체가 복사되어 전달된다.
* **특징:** 호출자(Caller)와 피호출자(Callee)의 변수는 완전히 독립적이다. 피호출자에서 값을 변경해도 호출자의 원본에는 아무런 영향을 주지 않는다.

### 2.2. Call by Reference (참조에 의한 호출)

* **대상:** 배열, 객체 등 참조 자료형(Reference Type).
* **동작:** 힙 영역에 존재하는 인스턴스의 **주소값(Reference)**이 복사되어 전달된다.
* **특징:** 두 변수가 **동일한 인스턴스**를 가리키게 된다. 따라서 피호출자가 데이터를 수정하면, 호출자가 참조하는 원본 데이터도 함께 변경된다.

### 2.3. 예외: String 클래스

* `String`은 참조 자료형이지만 **불변(Immutable)** 객체이다.
* 함수 내부에서 값을 변경하려 하면 기존 객체를 수정하는 것이 아니라, **새로운 문자열 객체를 생성**하여 변수가 그것을 가리키게 한다.
* 결과적으로 원본은 유지되므로, 마치 Call by Value처럼 동작하는 것으로 보인다.

---

## 3. Call by Reference의 메모리 동작 시뮬레이션

"참조를 전달한다"는 개념을 구체적인 메모리 주소 이동으로 시각화하면 다음과 같다.

### 3.1. 상황 설정

* `main` 함수에서 `int[] arr = {1, 2}`를 선언했다.
* 이 배열은 **Heap 영역의 0x100 번지**에 생성되었다고 가정한다.

| 영역 | 변수명 | 저장된 값 (Value) | 실제 의미 |
| --- | --- | --- | --- |
| **Stack (main)** | `arr` | **0x100** | 힙의 0x100번지를 가리킴 |
| **Heap** | (0x100) | `{1, 2}` | 실제 데이터 |

### 3.2. 함수 호출과 값 변경

함수 `testFunc(arr)`가 호출되고, 내부에서 `param[0] = 5`를 수행하는 과정이다.

1. **주소 복사:** `arr`가 가진 값 **0x100**이 복사되어 `testFunc`의 매개변수 `param`에 저장된다. (`param` == 0x100)
2. **참조 접근:** `param`은 **0x100** 번지를 찾아간다.
3. **데이터 수정:** 힙 영역 0x100번지의 첫 번째 요소(`1`)를 `5`로 덮어쓴다.
4. **결과:** 함수가 종료되어 `param`이 사라져도, 힙 영역(0x100)의 데이터는 이미 `{5, 2}`로 변경된 상태다.

---

## 4. 실전 코드 예제

위의 이론을 실제 Java 코드로 구현하여 원본 데이터가 변경되는 과정을 확인한다.

```java
public class MemoryTest {

    public static void main(String[] args) {
        // 1. Heap 영역에 정수형 배열 객체 생성 
        // (가정: 힙 주소 0x100, Stack의 arr에는 0x100이 저장됨)
        int[] arr = { 10, 20, 30 };
        
        System.out.println("함수 호출 전 arr[0]: " + arr[0]); // 출력: 10
        
        // 2. modifyArray 호출: arr의 주소값(0x100)이 param으로 복사됨
        modifyArray(arr); 
        
        // 4. 함수 종료 후: Heap 영역의 데이터가 변경되었음을 확인
        // arr는 여전히 0x100을 가리키고 있으며, 그곳의 데이터가 999로 바뀜
        System.out.println("함수 호출 후 arr[0]: " + arr[0]); // 출력: 999
    }

    public static void modifyArray(int[] param) {
        // param도 0x100을 가지고 있음
        // 3. param 참조를 통해 Heap(0x100)의 실제 데이터 변경
        param[0] = 999; 
        System.out.println("modifyArray 내부 변경 완료");
    }
}

```

---

## 5. 가비지 컬렉션(GC)의 동작 원리와 알고리즘

스택 프레임 소멸로 인해 힙 영역의 객체와 연결이 끊어졌을 때, 메모리를 정리하는 메커니즘이다.

### 5.1. 참조의 소멸과 Reachability

GC는 객체의 생존 여부를 판단하기 위해 **Reachability(도달 가능성)** 개념을 사용한다.

* **Root Set:** 힙 영역의 객체를 참조하는 시작점들(Stack의 지역변수, Method Area의 static 변수 등).
* **Reachable:** Root Set에서부터 참조 사슬을 따라 도달할 수 있는 객체 (유효함).
* **Unreachable:** Root Set에서 참조가 끊겨 더 이상 접근할 수 없는 객체 (수거 대상).

### 5.2. Mark and Sweep 알고리즘

가장 기본적인 GC 알고리즘의 동작 순서다.

1. **Mark (표시):** Root Set에서 시작하여 참조된 모든 객체를 추적하고, 살아있는 객체에 마킹(Marking)을 한다.
2. **Sweep (청소):** 힙 영역 전체를 스캔하여 마킹되지 않은(Unreachable) 객체들을 메모리에서 해제한다.

### 5.3. 요약: 함수 종료 후의 메모리 변화

1. 함수가 반환되면 **스택 프레임이 제거**된다.
2. 프레임 내부의 **참조 변수(Root)들이 소멸**한다.
3. 해당 변수가 가리키던 힙 영역의 객체는 **Unreachable 상태**가 된다.
4. GC가 주기적으로 실행될 때 이 객체를 식별하여 **메모리를 회수**한다.

---

**다음 단계로 무엇을 도와드릴까요?**

* 가비지 컬렉션이 일어날 때 애플리케이션이 잠시 멈추는 'Stop-the-world' 현상에 대해 알아볼까요?
* Java 힙 메모리 구조인 Young Generation과 Old Generation의 차이점을 정리해 드릴까요?
