---
title: 자바 배열의 참조와 복사 (Shallow vs Deep Copy)
date: 2025-12-21 18:25 +0900
author: hyesung
description: 자바 배열의 메모리 구조적 특징인 참조(Reference)의 개념을 정의하고, 이를 바탕으로 얕은 복사(Shallow Copy)와 깊은 복사(Deep Copy)의 차이점을 알아보자
categories: JAVA
---
## 자바 배열의 참조와 복사 (Shallow vs Deep Copy) 및 구현 비교

이 문서는 자바 배열의 메모리 구조적 특징인 참조(Reference)의 개념을 정의하고, 이를 바탕으로 얕은 복사(Shallow Copy)와 깊은 복사(Deep Copy)의 차이점을 기술한다. 또한, `clone()`과 `System.arraycopy()`를 포함한 구체적인 구현 코드와 특징을 정리한다.

---

### 1. 배열의 구조적 본질: 참조자(Reference)

자바에서 배열은 **클래스(Class)** 로 구현된 객체다. 따라서 배열 변수(식별자)는 실제 데이터 자체가 아닌, 데이터가 저장된 위치를 가리키는 **참조자** 역할을 수행한다.

* **메모리 할당:** `new` 연산을 통해 생성된 배열 인스턴스는 JVM의 **Heap(힙) 영역**에 저장되며, 변수는 이 인스턴스의 위치 정보(참조값)를 저장한다.
* **식별자의 역할:** 식별자는 인스턴스 자체가 아니며, 인스턴스에 접근하기 위한 주소값을 담고 있다. 엑셀의 참조 기능(예: B3 셀이 E5 셀을 참조)과 유사하게 작동한다.
* **스코프(Scope)와 생명주기:** 식별자는 선언된 스코프 내에서만 존재한다. 스코프가 종료되어 식별자가 소멸하면, 참조되지 않는 인스턴스는 추후 가비지 컬렉터(Garbage Collector)에 의해 메모리에서 회수된다.

---

### 2. 얕은 복사 (Shallow Copy)

**얕은 복사**는 실제 인스턴스(데이터)를 복제하는 것이 아니라, 인스턴스를 가리키는 **참조값(주소)만 복사**하는 방식이다.

* **동작 원리:**
	* 새로운 배열 변수 `dest`에 기존 배열 변수 `source`를 대입한다 (`int[] dest = source;`).
	* 메모리에 새로운 배열 인스턴스가 생성되지 않는다.
	* 두 변수가 **동일한 인스턴스**를 가리키게 된다 (Object ID가 동일함).


* **특징 및 부작용:**
	* 하나의 인스턴스를 두 개의 식별자가 공유하는 형태다.
	* `dest`를 통해 배열 요소를 수정하면, `source`를 통해 접근했을 때도 수정된 값이 확인된다.
	* 데이터 동기화가 의도치 않게 발생하므로 원본 보존이 필요한 경우 사용에 주의해야 한다.



---

### 3. 깊은 복사 (Deep Copy)

**깊은 복사**는 참조값만 복사하는 것이 아니라, 새로운 메모리 공간을 확보하고 원본의 **데이터 자체를 통째로 복제**하는 방식이다.

* **동작 원리:**
	* `new` 연산 등을 통해 원본과 동일한 크기의 새로운 인스턴스를 생성한다.
	* 원본 배열의 모든 요소를 새로운 인스턴스에 하나씩 복사한다.
	* 두 변수는 **서로 다른 인스턴스**를 가리키게 된다 (Object ID가 다름).


* **특징:**
	* 원본(`source`)과 사본(`dest`)이 완전히 독립적인 메모리 공간을 갖는다.
	* 사본의 데이터를 수정해도 원본 데이터에는 아무런 영향을 주지 않는다.



---

### 4. 깊은 복사 구현 방법 및 코드 비교

자바에서 배열의 깊은 복사를 수행하는 주요 방법은 다음과 같다. 각 방식은 사용 편의성과 성능, 복사 범위 제어에 차이가 있다.

#### 4.1. 반복문 (Manual Loop)

새로운 배열을 `new`로 생성하고 `for` 문을 통해 요소를 1:1로 복사한다. 가장 기초적인 방식이다.

#### 4.2. clone() 메서드

배열 객체 자체에서 지원하는 메서드로, 가장 **간편하게 전체 복사**를 수행할 수 있다.

* **특징:** 별도의 로직 없이 메서드 호출 한 번으로 깊은 복사가 수행된다.
* **코드 예시:**
```java
int[] source = {10, 20, 30, 40, 50};

// clone()을 이용한 깊은 복사
int[] dest = source.clone();

dest[0] = 999; // 사본 수정

// 결과: source[0]은 10 유지, dest[0]만 999로 변경됨

```



#### 4.3. System.arraycopy()

시스템 클래스에서 제공하는 **Native Method**를 활용한다. 성능이 우수하며 **부분 복사**에 유리하다.

* **특징:**
* 운영체제 레벨의 기능을 활용하므로 대용량 데이터 복사 시 성능상 이점이 있다.
* 원본의 특정 위치에서 목적지의 특정 위치로, 원하는 길이만큼만 잘라서 복사할 수 있다.
* 사전에 목적지 배열(`dest`)을 미리 메모리에 할당(`new`)해 두어야 한다.


* **문법:** `System.arraycopy(src, srcPos, dest, destPos, length);`
* **코드 예시:**
```java
int[] source = {10, 20, 30, 40, 50};
int[] dest = new int[5]; // 목적지 공간 미리 할당 필요

// source의 0번 인덱스부터 dest의 0번 인덱스로 5개 요소 복사
System.arraycopy(source, 0, dest, 0, source.length);

dest[1] = 888; // 사본 수정

// 결과: 서로 다른 인스턴스이므로 source에 영향 없음

```



#### 4.4. 요약 비교

| 방식 | 특징 | 장점 | 단점 |
| --- | --- | --- | --- |
| **for loop** | 직접 요소 대입 | 로직 이해가 쉬움 | 코드가 길어짐 |
| **clone()** | 객체 메서드 사용 | **구현이 가장 간단함** | 전체 복사만 가능 |
| **System.arraycopy()** | 시스템 함수 사용 | **성능 우수**, 범위 지정 가능 | 매개변수가 많아 복잡함 |

---

### 5. 복사 상태 검증 (Debugging)

배열 복사가 제대로 이루어졌는지 확인하기 위해 IDE의 디버깅 기능을 활용한다.

* **Object ID 확인:** 디버그 모드에서 각 배열 변수의 고유 ID(Object ID)를 대조한다.
* **ID 동일:** 얕은 복사 상태 (같은 주소 참조).
* **ID 상이:** 깊은 복사 상태 (다른 주소 참조, 독립된 객체).
