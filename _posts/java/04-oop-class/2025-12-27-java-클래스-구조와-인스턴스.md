---
title: Java 클래스 구조와 JVM 메모리 관리
date: 2025-12-27 16:14 +0900
author: hyesung
description: 클래스의 기본 구조와 JVM의 메모리 관리 방식, 그리고 객체 초기화를 담당하는 생성자의 핵심 개념을 정리한다.
categories: JAVA
---
## 1. 클래스의 구성 요소와 멤버 초기화 메커니즘

Java에서 **클래스(Class)** 는 필드(Field)와 메서드(Method)가 결합된 집합체다. 필드는 객체의 상태를, 메서드는 객체의 행위를 정의하며, 이 둘을 합쳐 **멤버(Member)** 라 부른다.

### 필드의 초기화와 기본값

클래스 내부에 선언된 변수(필드)는 명시적으로 초기화하지 않아도 **JVM(Java Virtual Machine)**에 의해 기본값으로 초기화된다.

* **숫자형 타입**: `0`으로 초기화된다.
* **참조형 타입(Reference Type)**: `null`로 초기화된다.

이때 `0`과 `null`은 개념적으로는 차이가 있으나, 메모리 내부(이진수 수준)에서는 모두 비트가 0으로 채워진 상태를 의미한다. JVM은 인스턴스가 생성될 때 해당 메모리 영역을 0으로 싹 비우는 과정을 거치는데, 이를 **제로 초기화(Zero-initialization)** 라 한다.

---

## 2. JVM 메모리 아키텍처: Stack 영역과 Heap 영역

Java의 메모리 관리는 변수가 선언된 위치와 성격에 따라 크게 두 영역으로 나뉜다.

### 스택(Stack)과 힙(Heap)의 차이점

| 구분 | 스택(Stack) 영역 | 힙(Heap) 영역 |
| --- | --- | --- |
| **저장 대상** | 지역 변수, 매개변수 (자동 변수) | 인스턴스(객체), 배열 |
| **관리 방식** | 메서드 호출 종료 시 자동 제거 | **가비지 컬렉터(GC)**가 관리 |
| **할당 시점** | 컴파일 타임에 크기 결정 (정적) | 런타임에 결정 (**동적 할당**) |

### 동적 할당(Dynamic Allocation)의 의미

`new` 연산자를 사용하여 객체를 생성하는 행위는 런타임(Runtime)에 메모리를 확보하는 **동적 할당**이다. '동적(Dynamic)', '다이나믹', '런타임'은 하나의 스키마로 묶어서 이해해야 한다. 프로그램 실행 중에 필요한 만큼의 메모리를 운영체제가 아닌 JVM에 요구하여 힙 영역에 할당받는 것이 핵심이다.

---

## 3. 인스턴스 생성과 생성자(Constructor)의 역할

**생성자**는 객체가 생성되는 시점에 JVM에 의해 자동으로 호출되는 특수한 메서드다.

### 생성자의 주요 특징

1. **반환 타입이 없다**: 생성자는 호출자가 명시적으로 제어하는 일반 메서드와 달리, 인스턴스의 주소를 반환하는 `new` 연산자의 로직에 포함되므로 별도의 반환 값을 갖지 않는다.
2. **클래스명과 동일하다**: 함수 이름이 클래스 이름과 반드시 같아야 한다.
3. **초기화 로직 전담**: 필드 선언 시 할당한 값보다 생성자 내에서의 초기화 로직이 **우선순위**를 갖는다.

```java
public class MyTest {
    // 1. 필드 선언 시 초기화 (우선순위 낮음)
    private int data = 10;

    // 2. 기본 생성자 (Default Constructor)
    public MyTest() {
        // 3. 생성자 내부 초기화 (우선순위 높음)
        this.data = 20; 
        System.out.println("인스턴스가 생성되었습니다.");
    }

    public int getData() {
        return data;
    }
}

```

> **💡 Deep Dive: 내부 동작 원리 - 객체 생성 라이프사이클**
> 
> Java에서 `new` 키워드가 호출되면 다음과 같은 복잡한 내부 과정을 거친다.
> 1. **클래스 로딩**: 해당 클래스가 메모리에 없다면 **클래스 로더(Class Loader)** 가 `.class` 파일을 읽어 메타데이터를 메서드 영역에 올린다.
> 2. **메모리 할당**: 힙 영역에 인스턴스 변수들을 저장할 충분한 공간을 확보한다. (이때 TLAB - Thread Local Allocation Buffer 등이 사용되어 성능을 최적화한다.)
> 3. **제로 초기화**: 할당된 메모리 공간을 모두 0(`0` 혹은 `null`)으로 채운다.
> 4. **필드 초기화**: 코드 상에 명시된 필드 초기화 값(예: `int data = 10`)을 적용한다.
> 5. **생성자 실행**: 최종적으로 생성자 본문 코드를 실행하여 객체를 완성한다.
> 따라서 생성자 내부에서 수행하는 오퍼레이션이 최종 상태를 결정하게 된다.

---

## 4. 참조 변수와 가비지 컬렉션(GC)

Java에서 클래스 타입으로 선언된 변수는 객체 그 자체가 아니라 객체의 주소를 저장하는 **참조 변수(Reference Variable)**다. 이는 C/C++의 포인터와 유사한 개념이다.

### 참조 변수의 특징과 사이드 이펙트

하나의 인스턴스에 대해 여러 개의 참조 변수가 존재할 수 있다. 만약 참조 A를 통해 객체의 상태를 변경하면, 동일한 객체를 가리키던 참조 B도 변경된 값을 보게 된다. 이를 **의도치 않은 부작용(Side Effect)**이라 하며, 대규모 시스템에서 데이터 무결성을 해치는 주요 원인이 되므로 주의가 필요하다.

### 가비지 컬렉터(Garbage Collector)

더 이상 어떤 참조 변수도 가리키지 않게 된(Unreachable) 객체는 힙 영역의 '쓰레기(Garbage)'가 된다. JVM의 **가비지 컬렉터**는 마치 뷔페의 웨이터처럼 사용이 끝난 그릇(메모리)을 감지하여 자동으로 회수한다. 개발자가 직접 메모리를 해제할 필요가 없다는 점이 Java의 큰 강점이다.

---

## 5. 접근 제어자와 캡슐화(Encapsulation)

객체 지향 프로그래밍의 핵심 원칙 중 하나는 내부 데이터를 외부로부터 보호하는 것이다.

### 캡슐화 전략

1. **필드는 `private`으로 제한**: 외부에서 객체의 상태를 직접 변경하지 못하게 차단한다.
2. **메서드는 `public`으로 노출**: 필드에 접근하는 공식적인 통로인 **Getter**와 **Setter**를 제공한다.

```java
public class User {
    // 데이터를 외부로부터 감춘다 (정보 은닉)
    private int age;

    // 읽기 전용 통로 (Getter)
    public int getAge() {
        return age;
    }

    // 쓰기 전용 통로 (Setter) - 데이터 검증 로직 추가 가능
    public void setAge(int age) {
        if (age < 0) return; // 유효성 검사
        this.age = age;
    }
}

```

---

## 💡 Quiz: 학습 내용 확인하기

**Q1. Java에서 필드 선언 시 `int count = 10;`이라고 명시하고, 생성자에서 `this.count = 20;`이라고 작성했을 때, `new` 연산자로 생성된 객체의 `count` 값은 무엇이며 그 이유는 무엇인가?**

<details>
<summary>정답 확인</summary>
정답: **20**. JVM의 객체 생성 라이프사이클상, 필드 초기화가 먼저 수행된 후 마지막에 생성자(Constructor)가 실행되면서 기존 값을 덮어쓰기 때문이다.
</details>

**Q2. `MyClass ref = null;` 상태에서 `ref.getData();`와 같이 멤버에 접근하려고 할 때 발생하는 예외는 무엇이며, 이 현상이 발생하는 근본적인 원인은 무엇인가?**

<details>
<summary>정답 확인</summary>
정답: **NullPointerException**. 참조 변수 `ref`가 힙 영역에 생성된 실제 인스턴스의 주소를 가지고 있지 않은 상태(0인 상태)에서, 존재하지 않는 메모리 주소의 멤버에 접근하려고 시도했기 때문이다.
</details>

**Q3. 생성자 내부에서 복잡한 로직(다른 클래스 생성, 네트워크 연결 등)을 작성하지 말아야 하는 기술적인 이유는 무엇인가?**

<details>
<summary>정답 확인</summary>
정답: 생성자는 오직 **'객체 자신의 초기화'**에 집중해야 한다. 생성자에서 외부 객체와의 과도한 결합(오지랖)이 발생하면, 객체 생성 과정에서 예외가 발생했을 때 객체가 불완전한 상태로 남게 되거나 디버깅이 극도로 어려워지는 등 유지보수성이 저하되기 때문이다.
</details>