---
title: Object 클래스와 동등성, 동일성
date: 2026-01-21 20:13 +0900
author: hyesung
mermaid: "true"
categories: JAVA 08-GC
---
## 1. 개요: 인스턴스와 참조의 분리

Java 프로그래밍에서 '같다'라는 개념은 두 가지 차원에서 해석된다. JVM의 Heap 영역에 생성된 **인스턴스(Instance)** 그 자체와, 이를 가리키는 Stack 영역의 **참조 변수(Reference Variable)** 사이의 관계를 명확히 이해해야 한다.

C/C++ 언어의 포인터와 유사하게, Java의 참조 변수는 실제 데이터가 저장된 메모리 주소를 가리킨다. 하지만 JVM은 개발자가 실제 물리 메모리 주소에 접근하는 것을 허용하지 않으며, 대신 객체 식별을 위한 **해시코드(HashCode)** 시스템을 제공한다.

## 2. 메모리 아키텍처와 객체 식별

두 변수가 '같다'고 할 때, 그것이 **"같은 대상을 가리키는가"**인지 **"대상의 내용이 같은가"**인지는 메모리 구조를 통해 시각화할 때 가장 명확해진다.

```mermaid
flowchart TD
    subgraph StackArea [Stack Area]
        RefA["RefVar A (0x100)"]
        RefB["RefVar B (0x200)"]
        RefC["RefVar C (0x100)"]
    end

    subgraph HeapArea [Heap Area]
        Obj1[("Instance A : Value 10")]
        Obj2[("Instance B : Value 10")]
    end

    RefA -->|Reference| Obj1
    RefB -->|Reference| Obj2
    RefC -->|Reference| Obj1

    %% 스타일 정의
    classDef stack fill:#e1f5fe,stroke:#333,stroke-width:2px;
    classDef heap fill:#f9f9f9,stroke:#333,stroke-width:2px;
    classDef heap2 fill:#d1e7dd,stroke:#333,stroke-width:2px;

    class RefA,RefB,RefC stack;
    class Obj1 heap;
    class Obj2 heap2;
```

* **RefVar A**와 **RefVar C**는 동일한 인스턴스(`Instance A`)를 가리킨다. (동일성 성립)
* **RefVar A**와 **RefVar B**는 서로 다른 인스턴스를 가리키지만, 내부 값(10)은 같다. (동등성 성립 가능)

> **Deep Dive: JVM의 HashCode 생성 전략**
> 
> `Object.hashCode()`는 기본적으로 객체의 내부 주소 값을 기반으로 생성된다고 알려져 있으나, 실제 HotSpot JVM 구현에서는 단순히 메모리 주소를 반환하지 않는다.
> 객체의 헤더(Mark Word)에 저장된 해시 값을 반환하거나, 난수 생성 알고리즘(XOR-Shift 등)을 사용하여 스레드 안전하게 생성한다. 따라서 해시코드는 "논리적인 메모리 주소 식별자" 역할을 한다.
{: .prompt-info }

## 3. 동일성(Identity) vs 동등성(Equality)

Java에서는 객체 비교를 위해 두 가지 개념을 엄격히 구분한다.

### 3.1 동일성 (Identity): `==` 연산자

* **정의**: 두 참조 변수가 물리적으로 **같은 메모리 주소**를 가리키고 있는가?
* **동작**: 스택에 저장된 참조 값(Reference Value) 자체를 비교한다.
* **특징**: `RefA == RefC`는 `true`이지만, `RefA == RefB`는 내용이 같아도 주소가 다르므로 `false`다.

### 3.2 동등성 (Equality): `equals()` 메서드

* **정의**: 두 인스턴스가 논리적으로 **같은 정보(내용)**를 담고 있는가?
* **동작**: `Object` 클래스의 기본 `equals()`는 내부적으로 `==` 연산을 수행한다. 즉, 오버라이딩(재정의)하지 않으면 동일성 비교와 똑같이 동작한다.
* **필요성**: 서로 다른 인스턴스라도(`new`로 각각 생성됨), 내부 필드 값이 같다면 '같은 객체'로 취급해야 하는 비즈니스 로직(예: 값 객체, VO)을 위해 재정의가 필요하다.

> **주의:** `String` 클래스는 이미 `equals()`가 재정의되어 있어 내용 비교가 가능하다. 하지만 개발자가 직접 만든 클래스(Custom Class)는 반드시 직접 재정의해야 한다.
{: .prompt-warning }

## 4. 구현: 올바른 equals() 재정의

강의 예제에 나온 `Minion` 클래스를 통해 올바른 비교 로직을 구현해 보자.

### 4.1 잘못된 비교 (기본 구현 사용)

```java
public class Minion {
    private int id;
    private String name;

    public Minion(int id, String name) {
        this.id = id;
        this.name = name;
    }

    public static void main(String[] args) {
        // 내용은 같지만 서로 다른 메모리에 할당된 두 객체
        Minion m1 = new Minion(1, "Kevin");
        Minion m2 = new Minion(1, "Kevin");

        // [Identity Check] 주소값 비교 -> false
        if (m1 == m2) {
            System.out.println("참조가 같습니다.");
        } else {
            System.out.println("참조가 다릅니다."); 
        }

        // [Equality Check] Object의 기본 equals는 ==과 같음 -> false
        if (m1.equals(m2)) {
            System.out.println("논리적으로 같습니다.");
        } else {
            System.out.println("논리적으로 다릅니다."); 
        }
    }
}
```

### 4.2 올바른 비교 (재정의)

`equals()`를 재정의할 때는 **반사성, 대칭성, 추이성, 일관성, null 아님**의 5가지 규약을 준수해야 한다. 또한 `hashCode()`도 반드시 함께 재정의해야 컬렉션 프레임워크(HashMap, HashSet 등)에서 오동작을 방지할 수 있다[^1].

```java
import java.util.Objects;

public class Minion {
    private int id;
    private String name;

    public Minion(int id, String name) {
        this.id = id;
        this.name = name;
    }

    @Override
    public boolean equals(Object o) {
        // 1. 주소값(Identity)이 같으면 무조건 true (성능 최적화)
        if (this == o) return true;
        
        // 2. null이거나 클래스 타입이 다르면 false
        if (o == null || getClass() != o.getClass()) return false;
        
        // 3. 타입 캐스팅 후 실제 필드 값(내용) 비교
        Minion minion = (Minion) o;
        
        // primitive 타입은 == 비교, reference 타입은 equals 비교
        // id => int, name => String
        return id == minion.id && 
               Objects.equals(name, minion.name);
    }

    @Override
    public int hashCode() {
        // [중요] equals() 비교에 사용된 'id'와 'name' 필드를 그대로 사용하여 해시 생성
        return Objects.hash(id, name);
    }
}
```

> **Tip:** IntelliJ IDEA나 Eclipse 같은 IDE는 `Generate` 기능을 통해 `equals()`와 `hashCode()` 메서드를 규약에 맞게 자동으로 생성해 주는 기능을 제공한다.
{: .prompt-tip }

### 4.3 구현 로직 심층 분석 (Deep Dive)

위 코드의 `3. 타입 캐스팅 후 실제 필드 값 비교` 부분은 객체 비교의 핵심 로직이다. 이 코드가 왜 필요한지 상세히 분석한다.

**1. 다운캐스팅 (Downcasting)의 이유**

* `equals(Object o)` 메서드의 매개변수는 모든 클래스의 최상위 부모인 `Object` 타입이다.
* `Object` 타입의 참조 변수로는 자식 클래스인 `Minion`의 고유 필드(`id`, `name`)에 접근할 수 없다(보이지 않는다).
* 따라서 `Minion minion = (Minion) o;`와 같이 **명시적 형변환(Casting)** 을 수행해야만 비교 대상 객체의 필드 값을 꺼내올 수 있다.
* *주의: 형변환 전 반드시 `getClass()`나 `instanceof`로 타입 일치 여부를 확인해야 `ClassCastException`을 방지할 수 있다.*



**2. 필드별 비교 전략 (Primitive vs Reference)**

* **기본형(Primitive Type)**: `int id`와 같은 기본형 변수는 메모리(Stack)에 실제 값이 저장된다. 따라서 `==` 연산자로 값을 직접 비교하는 것이 가장 빠르고 정확하다.
* **참조형(Reference Type)**: `String name`과 같은 참조형 변수는 주소값을 가지므로, 내용 비교를 위해 `equals()`를 사용해야 한다.

> **Deep Dive: 왜 `name.equals()` 대신 `Objects.equals()`를 쓰는가?**
> 
> `name.equals(minion.name)`을 직접 호출할 때, 만약 내 객체의 `name` 필드가 `null`이라면 **NullPointerException**이 발생하여 프로그램이 비정상 종료된다.
> 반면, `java.util.Objects.equals(a, b)` 유틸리티 메서드는 내부적으로 `null` 체크를 먼저 수행한다. 따라서 비교하려는 필드 값이 `null`이어도 안전하게 비교(Null-safe)를 수행하여 `false`를 반환하거나 정상 동작할 수 있다.
{: .prompt-info }

## 5. hashCode와 equals의 관계 및 동작 원리

`HashSet`이나 `HashMap` 같은 해시 기반 컬렉션은 방대한 데이터를 빠르게 검색하기 위해 **해시 버킷(Hash Bucket)** 방식을 사용한다. 이 메커니즘은 마치 **호텔에서 투숙객의 방을 배정하고 찾는 과정**과 유사하다.

아래 다이어그램과 상세 설명을 통해 내부 동작을 살펴보자.

```mermaid
flowchart LR
    subgraph RetrievalProcess [HashMap Retrieval Process]
        direction LR
        %% 노드 정의
        Search["검색: Minion(1, Kevin)"]
        HashResult{"Hash 100"}
        Bucket2["Bucket Index 2"]
       
        Item1["Minion(1, Kevin)"]
        Item2["Minion(2, Bob)"]

        %% 연결 로직 (숫자로 시작하지 않도록 수정)
        Search -->|"Step 1. hashCode() 호출"| HashResult
        HashResult -->|"Step 2. 나머지 연산 (%)"| Bucket2
       
        Bucket2 -->|"Step 3. equals() 비교"| Item1
        Bucket2 -.->|"불일치"| Item2
    end

    %% 스타일 정의
    classDef yellow fill:#fff3cd,stroke:#333,stroke-width:2px;
    classDef green fill:#d1e7dd,stroke:#333,stroke-width:2px;

    class Search,HashResult yellow;
    class Bucket2,Item1,Item2 green;
```

### 5.1 단계별 상세 분석

**Step 1: 해시 코드 생성 (식별 번호 발급)**

* **비유**: 호텔 프론트에서 손님(객체)의 신분증을 보고 고유 번호를 발급하는 과정이다.
* **동작**: `Minion(1, Kevin)` 객체의 `hashCode()` 메서드가 실행된다. `id`와 `name` 값을 조합하여 정수값(예: `100`)을 반환한다.
* **역할**: 객체 전체를 다루는 대신, 다루기 쉬운 정수(숫자) 하나로 요약하여 1차 식별을 수행한다.

**Step 2: 버킷 인덱스 결정 (방 배정)**

* **비유**: 고유 번호 `100`번 손님을 호텔에 있는 `10개`의 방 중 하나에 배정하는 과정이다.
* **동작**: 해시 코드(`100`)는 호텔 방 개수(배열 크기, 예: 49)보다 클 수 있다. 따라서 **나머지 연산(Modulo, %)**을 통해 실제 들어갈 방 번호(Index)를 정한다.
* *공식*: `100 (해시코드) % 49 (방 개수) = 2 (나머지)`
* **결과**: 이 데이터는 **2번 버킷(Bucket)**에 저장된다.

**Step 3: 버킷 내 검색 및 동등성 비교 (진짜 주인 찾기)**

* **비유**: 2번 방 문을 열고 들어가서, 그 안에 있는 사람들 중 내가 찾는 손님이 맞는지 얼굴을 대조하는 과정이다.
* **동작**: 해시 충돌(Hash Collision)로 인해 2번 버킷 안에는 여러 객체가 리스트 형태로 존재할 수 있다. 이때 비로소 **`equals()`**가 사용된다.
* **중요:** 이때 실행되는 `equals()`는 부모인 `Object` 클래스의 메서드가 아니라, **개발자가 재정의(Override)한 메서드**다.
* 이는 자바의 **다형성(Polymorphism)**과 **동적 바인딩(Dynamic Dispatch)** 원리에 의해, 실제 인스턴스 타입인 `Minion`의 메서드가 우선 호출되기 때문이다. 덕분에 우리는 `id`와 `name`을 기반으로 정확한 내용 비교를 수행할 수 있다.



> **Deep Dive: 왜 hashCode와 equals를 같이 재정의해야 하는가?**
> 
> 만약 **`equals()`만 재정의하고 `hashCode()`를 재정의하지 않았다면** 어떤 재앙이 발생할까?
> 1. **저장할 때**: `Minion(1, Kevin)`을 저장할 때, 자바는 이 객체의 메모리 주소를 기반으로 해시코드 `100`을 만들어 **2번 버킷**에 넣었다.
> 2. **찾을 때**: 나중에 똑같은 내용의 `Minion(1, Kevin)` 객체를 새로 만들어 검색을 시도한다. 내용은 같지만 **새로 만든 객체이므로 메모리 주소가 달라** 해시코드가 `5000`이 나와버린다.
> 3. **결과**: `5000 % 49`를 계산하니 **5번 버킷**을 가리킨다. 데이터는 2번 방에 있는데, 엉뚱한 5번 방을 뒤지게 된다. 당연히 5번 방에는 데이터가 없으므로(`null`), `equals()`로 비교해 볼 기회조차 얻지 못하고 "데이터 없음" 오류가 발생한다.
{: .prompt-danger }

## 6. 결론

Java에서 객체의 "같음"을 논할 때는 항상 **"주소가 같은가(Identity)?"** 아니면 **"내용이 같은가(Equality)?"**를 명확히 구분해야 한다.

* 단순히 `new`로 생성된 객체들을 `==`로 비교하면, 내용이 같아도 항상 `false`가 반환된다.
* 비즈니스 로직상 내용 비교가 필요하다면 반드시 `equals()`를 재정의하여 논리적 동등성을 보장해야 한다.

---

## 💡 Quiz: 학습 내용 확인하기

**Q1. `Object` 클래스의 기본 `equals()` 메서드는 내부적으로 어떤 연산자를 사용하여 비교하는가?**

<details>
<summary>정답 확인</summary>
<div>
== 연산자 (즉, 메모리 주소를 비교하는 동일성 비교를 수행한다.)
</div>
</details>

**Q2. 두 객체의 `equals()` 결과가 `true`일 때, 두 객체의 `hashCode()` 값은 달라야 하는가, 같아야 하는가?**

<details>
<summary>정답 확인</summary>
<div>
반드시 같아야 한다. Java 규약상 equals()가 true인 두 객체는 같은 hashCode() 값을 반환해야 Hash 기반 컬렉션에서 정상적으로 동작한다.
</div>
</details>

**Q3. 기본형(Primitive Type)인 `int`형 변수 `a`와 `b`를 비교할 때 `equals()` 메서드를 사용할 수 없는 이유는?**

<details>
<summary>정답 확인</summary>
<div>
기본형은 객체(Object)가 아니므로 메서드를 가질 수 없다. 따라서 항상 == 연산자를 통해 값을 비교해야 한다.
</div>
</details>

---

[^1]:`equals`가 `true`인 두 객체는 반드시 같은 `hashCode`를 가져야 한다는 Java의 규약(Contract) 때문이다. 이를 어길 경우 `HashSet`이나 `HashMap`의 키로 사용할 때 객체를 찾지 못하는 버그가 발생한다.