---
title: "Java 산술 연산의 임시 결과 & 타입 프로모션(Type Promotion)"
date: 2025-11-16 22:30 +0900
author: "hyesung"
description: "설명"
categories: JAVA
---
# Java 산술 연산의 임시 결과 & 타입 프로모션(Type Promotion) 완전 이해하기

## 1. 들어가며  
Java에서 산술 연산을 할 때는 눈에 보이지 않는 두 가지 일이 항상 벌어진다.

- **임시 결과(Temporary Result)** 생성
- **타입 프로모션(Type Promotion, 형 승격)** 적용

이 두 개념은 연산자, 데이터 타입, 성능, 오류 발생 원인과도 밀접한 관련이 있다. 겉으로는 단순히 `a + b`처럼 보이지만, 내부적으로는 훨씬 더 많은 과정이 일어난다.

---

## 2. 임시 결과(Temporary Result)란 무엇인가?

### ✔ 연산 과정에서만 잠시 존재하는 값
예:

```java
int a = 10;
int b = 20;
int c = a + b;
````

`a + b`는 바로 `c`에 들어가는 게 아니라:

1. `a` 값(10)을 가져온다
2. `b` 값(20)을 가져온다
3. CPU에서 `10 + 20 = 30` 계산
4. **30이라는 임시 결과 값이 메모리/레지스터에 잠깐 저장된다**
5. 그 후 `c`에 최종 값으로 저장된다

고로, **임시 결과란 “연산 중 간헐적으로 발생하는 중간 결과”** 이다.

---

### ✔ 복잡한 식일수록 임시 결과도 늘어난다

```java
int x = 5;
int y = 2;
int z = x * 3 + y * 4;
```

내부 처리 순서는 이렇다:

* `x * 3` → 15 (**임시 결과 #1**)
* `y * 4` → 8 (**임시 결과 #2**)
* `15 + 8` → 23 (**임시 결과 #3**)
* 최종 결과 23을 `z`에 저장

**눈에 보이지 않지만 연산 과정에서는 계속 생성·소멸된다.**

---

## 3. 타입 프로모션(Type Promotion: 형(型) 승격)

### ✔ 작은 타입은 더 큰 타입으로 ‘올려서 계산’

Java 산술 연산에서는 다음 규칙이 적용된다:

* `byte, short, char` → **연산 시 자동으로 int로 승격**
* `int` 와 `long` 연산 → 결과는 `long`
* `int/long + float` → 결과는 `float`
* `정수 + double` → 결과는 `double`

즉, **작은 타입이 큰 타입에 흡수되는 것이다.**

---

### ✔ 왜 byte + byte가 byte로 계산되지 않을까?

```java
byte a = 10;
byte b = 20;
byte c = a + b; // ❌ 컴파일 에러
```

이 에러는 a+b 연산 결과가:

* byte + byte → **int로 승격**
* 즉, 결과는 `int 30`
* byte에 넣으려니 타입 불일치 발생

해결하려면 명시적 캐스팅이 필요하다:

```java
byte c = (byte)(a + b);
```

---

## 4. 임시 결과 & 타입 승격은 함께 일어난다

둘은 별개의 개념이 아니라 **항상 같이 동작**한다.

1. 연산을 하면 **임시 결과가 생기고**
2. 그 임시 결과는 **타입 승격 규칙을 따라 결정된다**

즉:

* 연산식이 있다 → 임시 결과 생성
* 임시 결과가 생성될 때 → Java는 타입 승격 규칙 적용

**임시 결과의 타입은 항상 프로모션이 반영된 형태다.**

---

## 5. 실전 예제로 이해하기

### 예제 1 — byte + byte 연산

```java
byte a = 100;
byte b = 30;
byte result = (byte)(a + b);
```

`a + b` 과정:

* byte + byte → **int 130 생성**
* byte로 변환 → **Overflow 발생**
* 최종 result 값은 -126

---

### 예제 2 — 정수 타입 섞기

```java
short s = 1;
int i = 2;
long l = 3;
long result = s + i + l;
```

순서:

1. `s + i` → 둘 다 int로 → 결과: int 3
2. `int 3 + long 3` → long으로 승격 → 결과: long 6

---

### 예제 3 — 부동소수점 섞기

```java
int a = 1;
float b = 2.0f;
double c = 3.0;
double result = a + b + c;
```

연산 과정:

1. `a + b` → float 3.0
2. `float 3.0 + double 3.0` → double 6.0

---

## 6. 핵심 요약

1. **임시 결과는 연산 중 잠깐 만들어지는 값이다.**
2. **Java는 연산 시 자동으로 타입 승격(Type Promotion)을 적용한다.**
3. byte, short, char는 연산 시 무조건 **int**가 된다.
4. 임시 결과의 타입 역시 승격이 반영된다.
5. 실수 타입이 포함되면 정수는 실수로 승격된다.
6. 이 모든 과정은 개발자가 직접 볼 수 없지만, 반드시 일어난다.

---

## 마치며

임시 결과는 마치 연산 과정에서 잠깐 거쳐가는 **“연산의 쉼표”**,
타입 승격은 데이터 손실 없이 연산을 진행하기 위한 Java 언어의 **“안전장치”**다.

이 둘의 작동 원리를 이해하면:

* 컴파일 에러 원인 파악
* 형 변환 전략 설계
* 값 손실 문제 해결

에 모두 도움이 된다.

Java 타입 시스템은 생각보다 정교하다.
컴파일러가 "왜 이걸 int라고 하지?" 의문이 든다면,
그 뒤엔 **임시 결과와 타입 승격**이 항상 존재한다.
