---
title: Java 접근 제어와 캡슐화
date: 2025-12-27 17:37 +0900
author: hyesung
description: 객체지향 프로그래밍(OOP)의 핵심은 단순히 코드를 숨기는 것이 아니라, 제작자와 사용자의 관점을 명확히 분리하여 '직관적이고 안전한 인터페이스'를 제공하는 데 있다.
---

## 1. 접근 제어 지시자: 내부와 외부의 경계 세우기

자바에서 **접근 제어 지시자(Access Modifier)** 는 클래스 내부의 정보(필드 및 메서드)를 외부로 얼마나 노출할지를 결정하는 중요한 문법적 장치다. 이는 단순히 보안을 위한 것이 아니라, 객체 간의 의존 관계를 정의하고 관리하기 위해 존재한다.

### 접근 제어의 기본 원칙

* **내부 접근**: 클래스 내부에서 자기 자신의 멤버를 호출하는 행위는 제약 없이 허용된다.
* **외부 접근**: 다른 클래스에서 특정 객체의 필드나 메서드에 접근하는 것을 통제한다.

### 지시자의 종류와 허용 범위

자바는 네 가지 수준의 접근 제어를 제공한다.

| 지시자 | 동일 클래스 | 동일 패키지 | 자식 클래스 (상속) | 외부 클래스 |
| --- | --- | --- | --- | --- |
| **public** | O | O | O | O |
| **protected** | O | O | O | X |
| **default** | O | O | X | X |
| **private** | O | X | X | X |

> **💡 핵심 가이드**: 모든 필드(데이터)는 기본적으로 **private**으로 선언하여 외부 접근을 철저히 차단하는 것에서 시작해야 한다. 이후 외부와의 소통이 반드시 필요한 경우에만 단계적으로 접근 권한을 완화하는 것이 안전한 설계의 기본이다.

---

## 2. 객체지향의 철학: 제작자(Creator) vs 사용자(User)

강의에서는 객체지향을 잘한다는 것의 척도로 **제작자**와 **사용자**의 관점을 분리하는 능력을 꼽는다. 이 두 관점의 차이는 설계의 정교함을 결정짓는다.

### 직관성과 간결함의 미학

* **사용자 관점**: 객체를 사용하는 사람은 내부 로직이 어떻게 돌아가는지 알 필요가 없다. 버튼 하나만 누르면 작동하는 iPhone처럼, 인터페이스는 **직관적**이고 **간결**해야 한다.
* **제작자 관점**: 사용자가 실수를 하지 않도록 내부 구조를 정교하게 감추고(Encapsulation), 오직 필요한 통로(Interface)만을 열어두어야 한다.

과거 구글의 **Project Ara**(조립식 스마트폰)가 대중화에 실패한 사례는 시사하는 바가 크다. 개발자에게는 자유도가 높은 조립식이 매력적일 수 있지만, 일반 사용자에게는 복잡성만 가중시킬 뿐이다. 반면 하드웨어를 폐쇄적으로 관리하고 사용자 경험을 단순화한 iPhone은 시장을 선도했다. 소프트웨어 설계 역시 이와 같아서, 내부를 복잡하게 노출하기보다 최소한의 기능만을 외부에 공개하는 것이 유지보수와 안정성 면에서 압도적으로 유리하다.

---

## 3. 데이터 캡슐화의 실현: Getter와 Setter

필드를 `private`으로 감춘 뒤, 이에 안전하게 접근하기 위해 사용하는 도구가 바로 **Getter**와 **Setter** 메서드다.

```java
class UserData {
    // 1. 모든 필드는 private으로 선언하여 직접 접근을 차단함
    private String name;
    private int age;

    // 2. Getter: 내부 필드 값을 안전하게 읽기 위한 통로
    public String getName() {
        return this.name;
    }

    // 3. Setter: 필드 값을 변경할 때 검증 로직을 포함할 수 있음
    public void setAge(int age) {
        if (age < 0) { // 비정상적인 데이터 유입 차단
            this.age = 0;
            return;
        }
        this.age = age;
    }
}

```

### Getter/Setter를 사용해야 하는 이유

1. **데이터 무결성 보장**: `setAge(-5)`와 같은 비논리적인 데이터 입력을 메서드 수준에서 차단할 수 있다.
2. **읽기/쓰기 권한 분리**: 특정 데이터에 대해 Getter만 제공하면 외부에서는 읽기 전용(Read-Only) 필드로 인식하게 된다.
3. **디버깅 용이성**: 필드 값을 직접 수정하면 누가 언제 바꿨는지 추적하기 어렵지만, 메서드를 통하면 **Call Stack** 분석을 통해 변경 지점을 명확히 파악할 수 있다.
4. **프레임워크 규약**: **Spring Framework**와 같은 현대적인 프레임워크들은 객체를 자동으로 조작할 때 이 Getter/Setter 규약을 기반으로 동작하므로, 이를 준수하는 것은 선택이 아닌 필수다.

---

> **💡 Deep Dive: JVM의 접근 제어 검증과 성능 최적화**
> Java의 접근 제어는 단순히 컴파일러 수준에서만 체크되는 것이 아니다. 클래스 로딩 과정 중 **Linking - Verification(검증)** 단계에서 JVM은 바이트코드가 유효한 접근 권한을 가지고 있는지 엄격하게 검사한다. 만약 리플렉션(Reflection) 등을 이용해 `private` 멤버에 강제로 접근하려 할 때 보안 관리자가 이를 허용하지 않으면 런타임 에러가 발생한다.
> 또한, "매번 메서드(Getter)를 호출하면 필드 직접 접근보다 성능이 떨어지지 않을까?"라는 우려가 있을 수 있다. 하지만 현대의 JVM은 **JIT 컴파일러**의 **메서드 인라이닝(Method Inlining)** 기술을 통해 이를 최적화한다. 단순한 Getter/Setter 메서드는 런타임에 메서드 호출 오버헤드 없이 해당 필드 접근 코드로 직접 치환되어, 캡슐화의 이점과 직접 접근의 성능을 동시에 챙길 수 있다.

---

## 💡 Quiz: 학습 내용 확인하기

**질문 1. `protected` 접근 제어 지시자가 허용하는 접근 범위는 어디까지인가요?**

<details>
<summary>정답 확인</summary>
동일 클래스 내부, 동일 패키지 소속 클래스, 그리고 해당 클래스를 상속받은 다른 패키지의 자식 클래스까지 접근을 허용합니다.
</details>

**질문 2. 필드를 직접 공개하지 않고 Getter/Setter 메서드를 통해 접근하게 함으로써 얻는 디버깅 측면의 이점은 무엇인가요?**

<details>
<summary>정답 확인</summary>
메서드 호출을 통해 데이터가 변경되므로, 문제가 발생했을 때 콜 스택(Call Stack)을 분석하여 어떤 로직에서 해당 데이터가 수정되었는지 명확히 추적할 수 있습니다.
</details>

**질문 3. JVM의 클래스 로딩 과정 중 객체의 해시코드나 나이(Age) 정보가 기록되는 영역은 어디인가요?**

<details>
<summary>정답 확인</summary>
객체의 **Mark Word** (Object Header 내부) 영역입니다. 이곳에 해시코드, GC 세대 나이, 락 플래그 등의 메타 정보가 저장됩니다.
</details>
