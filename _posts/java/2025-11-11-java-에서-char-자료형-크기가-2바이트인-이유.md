---
title: JAVA 에서 char 자료형 크기가 2바이트인 이유
date: 2025-11-11 21:39 +0900
author: hyesung
description: Java 에서 char 자료형이 왜 2바이트인지 알아보자
categories: JAVA
---
# 💡 자바의 `char`는 왜 2바이트일까?

> 자바 `char` 타입의 크기는 1990년대 유니코드 설계 철학의 흔적이며, 현대 자바는 이를 보완하기 위해 **서로게이트 페어**와 **Compact String** 기술을 사용한다.

자바를 공부하다 보면 원시 타입(Primitive Type)의 크기를 외우게 된다. `byte`는 1바이트, `int`는 4바이트. 그런데 `char`는 애매하게 **2바이트(16비트)** 다. C언어의 `char`가 1바이트인 것과 비교하면 2배나 크다.

게다가 최근 많이 쓰는 이모지(😊)는 2바이트로 표현이 안 된다. 그렇다면 자바는 도대체 이 문자를 어떻게 저장하고 있을까? 단순히 "옛날 언어라서"라고 넘기기엔, 그 속에 담긴 **유니코드의 역사**와 **자바의 메모리 관리 전략**이 꽤 흥미롭다.

---

## 1. 태초에 '유니코드'가 있었다

결론부터 말하자면, 자바가 `char`를 2바이트로 정한 건 **1995년 당시의 "오판" 아닌 오판** 때문이었다.

자바가 탄생하던 시기, 전 세계 문자를 하나의 코드 체계로 통합하려는 **유니코드(Unicode)** 프로젝트가 한창이었다. 당시 개발자들은 **"2바이트(65,536개)면 전 세계 모든 문자를 다 담고도 남겠지?"** 라고 생각했다.

| 항목 | 내용 | 비고 |
| --- | --- | --- |
| **자바 탄생 시기** | 1995년 | 유니코드 1.0~2.0 시대 |
| **당시 가정** | 16비트 고정 길이면 충분하다 | 모든 문자를 `U+0000` ~ `U+FFFF`에 할당 |
| **결과** | `char` = 2바이트 (UTF-16) | 이후 문자가 폭발적으로 늘어남 |

이 결정 덕분에 자바는 초창기부터 한글이나 한자 같은 다국어를 별도의 라이브러리 없이도 `char` 하나에 깔끔하게 담을 수 있었다.

---

## 2. 16비트의 한계와 '이모지'의 습격

하지만 세상은 넓고 문자는 많았다. 고대 문자, 특수 기호, 그리고 **이모지(Emoji)** 가 등장하면서 65,536개 공간은 턱없이 부족해졌다. 현재 유니코드는 21비트(약 111만 개)까지 확장되었다.

문제는 여기서 발생한다. **자바의 `char`는 16비트로 고정**되어 있는데, **20비트가 넘는 이모지(😊, U+1F60A)** 가 들어온 것이다. 물리적으로 `char` 그릇이 작아 담을 수가 없다.

```java
char c = '😊'; // ❌ 컴파일 에러: "Too many characters in character literal"

```

---

## 3. 해결책: 서로게이트 페어 (Surrogate Pair)

자바는 이 문제를 해결하기 위해 **`char` 두 개를 묶어서 하나의 문자를 표현**하는 방식을 도입했다. 이를 **서로게이트 페어(Surrogate Pair)** 라고 한다.

* **1번 `char` (High Surrogate)**: `D800` ~ `DBFF` 범위
* **2번 `char` (Low Surrogate)**: `DC00` ~ `DFFF` 범위

이 두 개의 `char`가 연속으로 나오면, 자바는 이를 "글자 두 개"가 아니라 "특수 문자 한 개"로 인식한다.

### 문자열 길이의 함정

이 때문에 개발자들이 자주 겪는 혼란이 바로 `String.length()`다. 이 메서드는 **글자 수**가 아니라 **`char`의 개수**를 반환한다.

```java
public class CharLengthTest {
    public static void main(String[] args) {
        String emoji = "😊";
        
        // 1. 문자열 길이 (char 개수)
        System.out.println("length(): " + emoji.length()); 
        // 결과: 2 (내부적으로 char 2개를 사용하기 때문)

        // 2. 실제 문자 개수 (Code Point 개수)
        System.out.println("codePointCount: " + emoji.codePointCount(0, emoji.length())); 
        // 결과: 1 (우리가 보는 실제 이모지 개수)
    }
}

```

---

## 💡 Deep Dive: 자바 9 이후, String의 반란 (Compact Strings)

여기서 한 걸음 더 들어가 보자. `char`가 2바이트인 건 알겠는데, 그럼 영어(ASCII)만 쓰는 애플리케이션에서는 메모리가 너무 낭비되지 않을까? 영어 'A'는 1바이트(`0x41`)면 충분한데, 자바는 무조건 2바이트를 쓰니까 말이다.

이 문제를 해결하기 위해 **Java 9부터 `String`의 내부 구현이 완전히 바뀌었다.**

### 1. `char[]`에서 `byte[]`로 변경

기존에는 `String` 클래스가 내부적으로 `char[]`를 가졌다. 하지만 Java 9부터는 **`byte[]`** 를 사용한다.

### 2. 인코딩 플래그 (Coder)

String 객체는 이제 자신이 담고 있는 문자열이 **LATIN-1(1바이트)** 인지 **UTF-16(2바이트)** 인지를 구분하는 `coder`라는 필드를 가진다.

* **영어/숫자만 있다?**: `byte[]`에 1바이트씩 꾹꾹 눌러 담는다. (메모리 50% 절약)
* **한글/이모지가 있다?**: 기존처럼 2바이트씩(UTF-16) 사용하여 저장한다.

```java
// Java 9+ String 클래스 내부 (개념적 코드)
public final class String {
    private final byte[] value; // char[]가 아님!
    private final byte coder;   // 0: LATIN1, 1: UTF16
    // ...
}

```

즉, **`char` 자료형 자체는 여전히 2바이트**지만, 우리가 가장 많이 쓰는 **`String` 객체는 상황에 따라 1바이트 단위로 데이터를 최적화**해서 저장하고 있다. 이는 대규모 서버 애플리케이션에서 힙(Heap) 메모리 효율을 획기적으로 높여주는 기술이다.

---

## 4. 요약

1. **`char`는 2바이트다**: 유니코드 초기 설계(UTF-16)를 따랐기 때문이다.
2. **이모지는 `char`에 못 담는다**: `char` 두 개를 합친 '서로게이트 페어'로 처리되므로, 반드시 `String`이나 `int`(Code Point)로 다뤄야 한다.
3. **문자 수 셀 때 조심하자**: 이모지가 포함된 문자열의 길이를 정확히 세려면 `.length()` 대신 `.codePointCount()`를 사용해야 한다.
4. **최신 자바는 똑똑하다**: Java 9 이상을 쓴다면 영문 문자열은 자동으로 메모리가 절약된다(`byte[]` 저장).

---

## 💡 Quiz: 학습 내용 확인하기

<details>
<summary><strong>Q1. Java 9부터 String 내부에서 문자를 저장하기 위해 사용하는 배열 타입은 무엇인가요?</strong></summary>





<strong>정답: <code>byte[]</code></strong>




이전 버전까지는 <code>char[]</code>를 사용했으나, 메모리 효율을 위해 Java 9부터는 <code>byte[]</code>와 인코딩 플래그(coder)를 사용하는 Compact String 구조로 변경되었습니다. 
</details>

<details>
<summary><strong>Q2. 이모지(😊)가 포함된 문자열 "A😊"의 <code>.length()</code> 값은 얼마일까요?</strong></summary>





<strong>정답: 3</strong>





'A'는 1개의 <code>char</code>, '😊'는 서로게이트 페어로 2개의 <code>char</code>를 차지하므로 총 길이는 1 + 2 = 3이 됩니다.
</details>

<details>
<summary><strong>Q3. 유니코드 문자를 표현하기 위해 2개의 char를 사용하는 방식을 무엇이라고 부르나요?</strong></summary>





<strong>정답: 서로게이트 페어 (Surrogate Pair)</strong>





16비트(U+FFFF) 범위를 벗어나는 문자를 표현하기 위해 상위(High)와 하위(Low) 두 개의 16비트 값으로 문자를 표현하는 방식입니다.
</details>