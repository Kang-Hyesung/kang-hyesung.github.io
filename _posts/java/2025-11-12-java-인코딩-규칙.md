---
title: "JAVA 인코딩 규칙"
date: 2025-11-12 21:43 +0900
author: "hyesung"
description: "Java 문자열 인코딩의  — UTF-16, UTF-8, 그리고 Modified UTF-8"
categories: JAVA
---
## 1. 개요

자바(Java)에서 문자열은 단순히 눈에 보이는 글자 그 이상이다
문자열은 내부적으로 **JVM의 인코딩 체계(UTF-16)** 를 따르며,
입출력 시에는 **UTF-8 혹은 Modified UTF-8** 로 변환되어 처리된다.

이번 글에서는 `"가"` 한 글자를 예로 들어,
왜 IO 버퍼에서 `234, 176, 128` 같은 숫자가 나오는지,
그리고 자바 문자열 인코딩이 어떻게 동작하는지를 단계별로 살펴보자

---

## 2. 한글과 영문의 차이

| 문자  | 인코딩 체계           | 비트 크기      | 비고               |
| --- | ---------------- | ---------- | ---------------- |
| `A` | ASCII            | 8비트(1바이트)  | 영문자는 단일 바이트      |
| `가` | Unicode (UTF-16) | 16비트(2바이트) | 한글은 유니코드 체계에서 표현 |

즉, `A`는 1바이트, `가`는 2바이트(UTF-16 기준)로 저장된다.
하지만 IO 과정에서는 한글이 **3바이트**로 변환되는 현상이 생긴다.
그 이유는 바로 **UTF-8 인코딩 과정** 때문이다.

---

## 3. JVM 내부 인코딩: UTF-16 (Big Endian)

JVM(Java Virtual Machine)은 문자열을 내부적으로 **UTF-16 Big Endian** 방식으로 저장합니다.
즉, 자바 코드 내부에서 `"가"`를 쓴다면 이건 **16비트 유니코드 문자**로 처리됩니다.

```java
char ch = '가';
System.out.println((int)ch); // 44032
```

→ `'가'`의 유니코드 값은 **U+AC00 (10진수 44032)** 입니다.

---

## 4. 입출력(IO) 단계에서의 인코딩 변화

문자열이 입력되거나 출력될 때는 JVM 내부에서 다음과 같은 인코딩 흐름을 거칩니다.

```
+---------------------+
| JVM 내부 (UTF-16)   |
| "가" → U+AC00       |
+----------+----------+
           |
           v
+---------------------+
| 변환 (Encoding)     |
| UTF-16 → UTF-8      |
+----------+----------+
           |
           v
+---------------------+
| IO 버퍼 (UTF-8)     |
| EA B0 80 (3 bytes)  |
| 234, 176, 128       |
+---------------------+
```

즉, `"가"`라는 문자가
**UTF-16 (2바이트)** → **UTF-8 (3바이트)** 로 변환되어 IO 버퍼에 저장되는 구조입니다.

---

## 5. UTF-8의 가변 길이 인코딩

UTF-8은 문자에 따라 **1~4바이트**로 다르게 인코딩됩니다.

| 문자         | 바이트 수 | 예시                         |
| ---------- | ----- | -------------------------- |
| 영어 (ASCII) | 1바이트  | `A → 0x41`                 |
| 한글         | 3바이트  | `가 → 0xEA 0xB0 0x80`       |
| 이모지        | 4바이트  | `😀 → 0xF0 0x9F 0x98 0x80` |

따라서 `"가"`는 유니코드에서는 1문자이지만, UTF-8에서는 3바이트로 저장되므로
IO 스트림에서 **3개의 숫자**로 출력되는 것입니다.

---

## 6. Modified UTF-8 (자바 전용 인코딩)

JVM은 일반 UTF-8 대신 **Modified UTF-8**을 일부 상황에서 사용합니다.
이는 자바의 **Object Serialization, Class File, DataInputStream/DataOutputStream** 등에서 사용됩니다.

이 방식에서는 일반 UTF-8과 약간의 차이가 있습니다.

| 구분                 | UTF-8  | Modified UTF-8 |
| ------------------ | ------ | -------------- |
| `null` 문자 (U+0000) | `0x00` | `0xC0 0x80`    |
| 나머지 문자             | 동일     | 동일             |

즉, **자바에서는 문자열의 끝이 `null`(0)로 표시되지 않습니다.**
C나 C++처럼 `"문자열의 끝은 null"`이라는 개념이 적용되지 않습니다.

---

## 7. 자바 문자열 인코딩 구조 요약도

```
┌────────────────────────────┐
│  Java Source (.java)       │
│  └ 코드 상의 문자열 (UTF-16)│
│     ex) char c = '가';      │
└───────────────┬────────────┘
                │
                ▼
┌────────────────────────────┐
│  JVM 메모리 (UTF-16)       │
│  └ 내부적으로 U+AC00 저장   │
└───────────────┬────────────┘
                │
                ▼
┌────────────────────────────┐
│  IO 계층 (UTF-8 인코딩)    │
│  └ 0xEA 0xB0 0x80 (3 bytes)│
│     = 234, 176, 128        │
└───────────────┬────────────┘
                │
                ▼
┌────────────────────────────┐
│  파일/네트워크 전송 (바이트)│
│  └ 실제 데이터 스트림       │
└────────────────────────────┘
```

---

## 8. 핵심 요약 (TL;DR)

1. **JVM 내부 문자열 인코딩:** UTF-16 (Big Endian)
2. **입출력(IO) 시 인코딩:** UTF-8 (가변 길이)
3. **한글 한 글자(`가`)는 3바이트**로 표현 (`234, 176, 128`)
4. **Modified UTF-8**은 자바 전용 변형 규칙으로 `null` 문자를 다르게 처리
5. **문자열 깨짐의 대부분은 인코딩 설정 문제**로 해결 가능

---

## 9. 마무리

인코딩 문제는 단순히 “글자가 깨진다”의 문제가 아닙니다.
**데이터가 어떻게 저장되고, 어떤 규칙으로 해석되느냐의 문제**입니다.

특히 자바처럼 JVM 내부 인코딩(UTF-16)과 IO 인코딩(UTF-8)이 다른 언어에서는
이 차이를 모르면 문자열이 “엉뚱한 숫자”로 읽히거나 “깨진 문자”로 출력되는 문제가 생깁니다.

백엔드 개발자로 성장하려면 반드시 **인코딩 흐름을 머릿속에 그릴 수 있어야 합니다.**
설정만 올바르면 대부분의 인코딩 문제는 단 한 줄로 해결됩니다.

---

### 참고

* [Java Character Encoding — Oracle Docs](https://docs.oracle.com/javase/tutorial/i18n/text/unicode.html)
* [UTF-8 vs UTF-16 — Unicode.org](https://www.unicode.org/faq/utf_bom.html)

