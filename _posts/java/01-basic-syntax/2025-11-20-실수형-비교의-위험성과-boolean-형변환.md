---
title: 실수형 비교의 위험성과 Boolean 형변환
date: 2025-11-20 21:38 +0900
author: hyesung
categories: JAVA 01-basic-syntax
---
프로그래밍을 하다 보면 두 수가 같은지(`==`), 혹은 누가 더 큰지(`>`) 비교해야 할 때가 많다. 정수형(int) 데이터를 다룰 때는 직관적으로 이해가 되지만, 실수형(float, double)이나 논리형(boolean)의 내부 동작으로 넘어가면 예상치 못한 오해와 버그를 마주하게 되는 것이다.

오늘은 관계연산자의 내부 구현 원리를 통해 **왜 실수형 데이터에 등가비교(`==`)를 사용하면 안 되는지**, 그리고 **왜 Java에서는 Boolean을 정수로 바꿀 수 없는지** 정리해 본다.

-----

## 1\. 관계연산자의 작동 원리: "뺄셈"

우선 관계연산자(`>`, `<`, `==`, `!=`)가 컴퓨터 내부에서 어떻게 작동하는지 이해할 필요가 있다. 우리는 눈으로 숫자를 보고 비교하지만, 컴퓨터(CPU)는 **뺄셈**을 통해 이를 확인한다.

  * **상등(Equality) 확인:** $A - B$를 수행했을 때 결과가 $0$이 나오면 두 수는 **같다**고 판단한다.
  * **비교(Comparison) 확인:** 뺄셈의 결과가 양수인지 음수인지에 따라 크기를 판별하는 것이다.

-----

## 2\. Boolean은 int나 char로 변환할 수 없다

관계연산의 결과는 `true` 또는 `false`인 **Boolean(논리)** 형식으로 반환된다. 여기서 많은 개발자, 특히 C언어에 익숙한 개발자들이 자주 하는 오해가 있다. 바로 `true`를 `1`로, `false`를 `0`으로 생각하여 형변환을 시도하는 것이다.

### Java의 Boolean은 JVM 전용 형식이다

하지만 Java에서는 **Boolean을 `int`나 `char`로 강제 형변환(Casting)하는 것이 절대 불가능하다.**

  * **하드웨어 vs JVM:** 실제 CPU 하드웨어에는 `boolean`이라는 형식이 존재하지 않는다. CPU는 오직 정수(`int`)만 처리할 뿐이다. 하지만 Java의 \*\*JVM(Java Virtual Machine)\*\*은 추상화된 레벨에서 `boolean`이라는 독자적인 형식을 정의하여 관리한다.
  * **엄격한 타입 체크:** C언어에서는 논리값을 0과 1로 호환하여 쓰기도 하지만, Java는 이를 엄격히 구분한다. 따라서 아래와 같은 코드는 컴파일 에러를 발생시킨다.

<!-- end list -->

```java
boolean flag = true;

// C언어식 사고: true니까 1로 바뀌겠지?
// Java 결과: 컴파일 에러 (Inconvertible types)
int num = (int) flag; 

// 문자형으로도 변환 불가
char c = (char) flag; 
```

즉, **Boolean 타입은 오직 논리적 판단(`true`/`false`)을 위해서만 존재**하며, 이를 숫자나 문자로 치환하여 연산하려는 시도는 Java 문법상 **부적절한 변환**인 것이다.

-----

## 3\. 부동소수점 오차 (Floating Point Error)

또 하나의 중요한 이슈는 **'뺄셈을 통한 비교'** 로직을 \*\*실수(Float/Double)\*\*에 적용할 때 발생한다. 컴퓨터는 실수를 표현할 때 **부동소수점(Floating Point)** 방식을 사용하는데, 이 방식은 태생적으로 정밀도에 한계가 있어 미세한 오차를 포함하기 때문이다.

### 왜 위험한가?

실수는 내부적으로 완벽한 값을 저장하지 못하고 근사값을 저장하는 경우가 많다.

  * **0이 되지 않는 뺄셈:** 논리적으로는 같아야 할 두 실수를 뺐을 때, 오차로 인해 \*\*0이 아닌 아주 작은 값(Trash value)\*\*이 남게 될 수 있다.
  * **잘못된 상등 판정:** 반대로, 정밀도 한계를 벗어난 아주 작은 차이는 무시되어 서로 다른 값임에도 `true`가 반환되기도 하는 것이다.

### 코드 예시: 같지 않은데 같다고 나오는 경우

```java
// 상황: 정밀도 한계로 인한 오판
float f1 = 0.9999999F; 
float f2 = 1.0F;

// 논리적으로는 다른 수이지만, float의 정밀도를 벗어나면 같다고 판단할 수 있다
if (f1 == f2) {
    System.out.println("true"); // 출력될 가능성이 높음 (위험!)
}
```

-----

## 4\. 핵심 요약 및 결론

1.  **관계연산자는 뺄셈이다:** 내부적으로 뺄셈을 수행하여 0인지, 양수/음수인지로 판단한다.
2.  **Boolean 형변환 불가:** `boolean`은 JVM 수준의 추상화된 형식이다. C언어처럼 1, 0으로 생각하여 `int`나 `char`로 변환하려 하면 에러가 발생한다.
3.  **실수 비교 금지:** 부동소수점 오차 때문에 실수형 변수에 직접 `==` 연산을 사용하는 것은 결과를 신뢰할 수 없다.
4.  **결론:** **실수형끼리의 비교는 피하고, Boolean은 논리 연산 용도로만 사용해야 하는 것이다.**

