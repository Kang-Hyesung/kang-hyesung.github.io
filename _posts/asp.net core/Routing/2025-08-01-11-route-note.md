---
title: "[11] Route 총정리"
date: 2025-08-01 22:04 +0900
author: hyesung
---
ASP.NET Core 애플리케이션의 심장은 **라우팅(Routing)** 에 있다. 라우팅은 들어오는 HTTP 요청을 분석하여 어떤 코드(Controller Action, Razor Page, Minimal API 핸들러 등)가 처리해야 할지 결정하는 핵심 메커니즘이다. 잘 설계된 라우팅은 애플리케이션의 URL을 깔끔하고 의미 있게 만들어주며, 이는 API의 직관성과 사용성을 높이는 데 결정적인 역할을 한다. 🛣️

이 글에서는 ASP.NET Core 라우팅의 동작 원리부터 시작하여, 라우트 파라미터, 제약 조건, 그리고 우선순위 결정 알고리즘까지 깊이 있게 알아본다.

### 1. 라우팅의 핵심 원리: `UseRouting`과 `UseEndpoints`

ASP.NET Core의 라우팅은 두 개의 핵심 미들웨어(Middleware)에 의해 두 단계로 처리된다.

1. **`UseRouting()`**: 요청 매칭(Route Matching) 단계. 들어오는 요청의 URL과 HTTP 메서드를 분석하여 등록된 엔드포인트(Endpoint) 목록과 비교하고, 가장 적합한 엔드포인트를 찾아낸다. 이 미들웨어는 찾은 라우팅 정보를 `HttpContext`에 추가한다.
2. **`UseEndpoints()`**: 엔드포인트 실행(Endpoint Execution) 단계. `UseRouting`이 찾아낸 엔드포인트에 연결된 실제 코드를 실행한다.
    

이 두 미들웨어는 반드시 **`UseRouting()`이 먼저 호출되어야 한다**는 점이 중요하다. 매칭이 먼저 이루어져야 실행할 대상을 알 수 있기 때문이다.

```csharp
var app = builder.Build();

// 1. 라우팅 미들웨어를 활성화하여 요청을 분석하고 매칭할 준비를 한다.
app.UseRouting();

// 2. 매칭된 엔드포인트를 실행한다.
app.UseEndpoints(endpoints =>
{
    // 엔드포인트(라우트) 정의는 이 안에서 이루어진다.
    endpoints.MapGet("/home", async context => {
        await context.Response.WriteAsync("Welcome Home!");
    });
});

// 매칭되는 엔드포인트가 없을 경우 실행될 폴백(fallback) 미들웨어
app.Run(async context => {
    await context.Response.WriteAsync($"No route matched for {context.Request.Path}");
});

app.Run();
```

_참고: Minimal API 스타일(`.NET 6` 이상)에서는 `app.MapGet()` 등을 직접 호출하면 내부적으로 `UseRouting`과 `UseEndpoints`가 자동으로 관리되어 코드가 더 간결해진다._

---

### 2. 동적 URL 처리: 라우트 파라미터 (Route Parameters)

정적인 URL만으로는 복잡한 애플리케이션을 만들기 어렵다. 라우트 파라미터를 사용하면 URL의 일부를 변수로 받아 동적으로 처리할 수 있다.

- **필수 파라미터 `{parameter}`**: URL에 반드시 포함되어야 하는 값이다.
    
    - `files/{filename}.{extension}`: `filename`과 `extension`이 모두 있어야 매칭된다.
        
- **선택적 파라미터 `{parameter?}`**: URL에 값이 없어도 매칭된다. 코드에서는 `null`로 전달된다.
    
    - `products/details/{id?}`: `id` 값이 없어도 매칭된다.
        
- **기본값 파라미터 `{parameter=defaultValue}`**: URL에 값이 없으면 지정된 기본값을 사용한다.
    
    - `employee/profile/{EmployeeName=guest}`: `EmployeeName` 값이 없으면 "guest"가 사용된다.
        

#### 코드 예시

```csharp
app.UseEndpoints(endpoints =>
{
    // 필수 파라미터 예시
    endpoints.Map("files/{filename}.{extension}", async context =>
    {
        string? fileName = context.Request.RouteValues["filename"]?.ToString();
        string? extension = context.Request.RouteValues["extension"]?.ToString();
        await context.Response.WriteAsync($"File: {fileName}.{extension}");
    });

    // 기본값 파라미터 예시
    endpoints.Map("employee/profile/{EmployeeName=guest}", async context =>
    {
        string? employeeName = context.Request.RouteValues["employeename"]?.ToString();
        await context.Response.WriteAsync($"Profile for {employeeName}");
    });

    // 선택적 파라미터 예시
    endpoints.Map("products/details/{id?}", async context => 
    {
        if (context.Request.RouteValues.TryGetValue("id", out var idValue))
        {
            await context.Response.WriteAsync($"Product Details for ID: {idValue}");
        }
        else
        {
            await context.Response.WriteAsync("Product ID was not provided.");
        }
    });
});
```

파라미터 값은 `context.Request.RouteValues` 딕셔너리를 통해 조회할 수 있다.

---

### 3. 요청 필터링: 라우트 제약 조건 (Route Constraints)

라우트 제약 조건을 사용하면 파라미터가 특정 규칙을 따를 때만 라우트가 매칭되도록 할 수 있다. 이는 불필요한 요청을 핸들러 단계 이전에 걸러내고 코드를 깨끗하게 유지하는 데 매우 유용하다.

- **사용법**: `{parameter:constraint}` 형식으로 추가한다.
    
- **주요 내장 제약 조건**:
    
    - `int`, `bool`, `double`, `guid`: 특정 데이터 타입이어야 한다.
    - `alpha`: 영문자만 허용한다.
    - `length(min, max)`: 문자열 길이를 제한한다.
    - `range(min, max)`: 숫자 범위를 제한한다.
    - `regex(pattern)`: 정규 표현식 패턴과 일치해야 한다.
        

#### 코드 예시

```csharp
app.UseEndpoints(endpoints =>
{
    // id는 1에서 1000 사이의 정수여야 하며, 선택적이다.
    endpoints.Map("products/details/{id:int:range(1,1000)?}", async context => {
        // ...
    });

    // year는 1900 이상의 정수여야 하고, month는 지정된 분기 중 하나여야 한다.
    endpoints.Map("sales-report/{year:int:min(1900)}/{month:regex(^(apr|jul|oct|jan)$)}", async context =>
    {
        // ...
    });

    // cityid는 반드시 GUID 형태여야 한다.
    endpoints.Map("cities/{cityid:guid}", async context =>
    {
        // ...
    });
});
```

---

### 4. 고급 기술: 커스텀 제약 조건과 `GetEndpoint`

#### 커스텀 라우트 제약 조건 만들기

내장 제약 조건으로 부족할 경우, `IRouteConstraint` 인터페이스를 구현하여 자신만의 제약 조건을 만들 수 있다.

1. `IRouteConstraint`를 구현하는 클래스를 만든다.
2. `Match` 메서드 안에 원하는 유효성 검사 로직을 작성한다.

```csharp
// 특정 월(분기 시작 월)만 허용하는 커스텀 제약 조건
public class MonthsCustomConstraint : IRouteConstraint
{
    public bool Match(HttpContext? httpContext, IRouter? route, string routeKey, RouteValueDictionary values, RouteDirection routeDirection)
    {
        if (!values.ContainsKey(routeKey)) return false;

        string? monthValue = values[routeKey]?.ToString();
        var regex = new Regex("^(apr|jul|oct|jan)$", RegexOptions.IgnoreCase);

        return monthValue != null && regex.IsMatch(monthValue);
    }
}
```

사용법:

Program.cs에서 제약 조건을 서비스에 등록한 후 {month:months} 와 같이 사용한다.

```csharp
// Program.cs
builder.Services.AddRouting(options => {
    options.ConstraintMap.Add("months", typeof(MonthsCustomConstraint));
});

// ...

// 엔드포인트 정의
endpoints.Map("sales-report/{year:int:min(1900)}/{month:months}", ...);
```

#### 실행 중인 엔드포인트 정보 확인하기 (`GetEndpoint`)

미들웨어에서 현재 요청이 어떤 엔드포인트에 매칭되었는지 확인해야 할 때가 있다. 이때 `context.GetEndpoint()` 메서드를 사용한다. 이 메서드는 **`UseRouting()` 미들웨어 실행 이후**에만 유효한 값을 반환한다.

```csharp
// UseRouting() 이전에 실행되는 미들웨어
app.Use(async (context, next) => 
{
    // 이 시점에서는 GetEndpoint()가 항상 null을 반환한다.
    Endpoint? endPoint = context.GetEndpoint();
    Console.WriteLine($"Before Routing - Endpoint: {endPoint?.DisplayName ?? "null"}");
    await next(context);
});

app.UseRouting();

// UseRouting() 이후에 실행되는 미들웨어
app.Use(async (context, next) =>
{
    // 이 시점에서는 매칭된 엔드포인트 정보를 가져올 수 있다.
    Endpoint? endPoint = context.GetEndpoint();
    Console.WriteLine($"After Routing - Endpoint: {endPoint?.DisplayName ?? "null"}");
    await next(context);
});
```

---

### 5. 라우팅의 우선순위: 엔드포인트 선택 알고리즘

만약 하나의 요청이 여러 엔드포인트에 매칭될 수 있다면? ASP.NET Core는 다음 순서에 따라 가장 적합한 엔드포인트를 선택한다.

1. **더 구체적인 라우트가 우선**: `/products/{id}`는 `/products`보다 구체적이므로 먼저 선택된다.
2. **더 많은 제약 조건을 가진 라우트가 우선**: `{id:int}`는 `{id}`보다 더 구체적이므로 우선한다.
3. **위 조건이 동일하면 먼저 등록된 라우트가 우선**: 코드상 위에 작성된 라우트가 선택된다.

만약 시스템이 명확하게 하나의 엔드포인트를 결정할 수 없다면 `AmbiguousMatchException` 예외가 발생한다.

---

### Java Spring에서는?

C#의 ASP.NET Core 라우팅 개념은 Java의 Spring Boot와 매우 유사하게 매핑된다.

- **엔드포인트 정의 (`Map*` ↔ `@RestController`, `@GetMapping`)**:
    
    - **ASP.NET Core**: `app.MapGet("/api/products", ...)`
    - **Spring Boot**: `@RestController` 클래스 내부에 `@GetMapping("/api/products")` 어노테이션을 붙인 메서드를 사용한다.
        
    
    ```java
    @RestController
    public class ProductController {
        @GetMapping("/api/products")
        public List<Product> getAllProducts() {
            // ... 로직
        }
    }
    ```
    
- **라우트 파라미터 (`RouteValues` ↔ `@PathVariable`)**:
    
    - **ASP.NET Core**: `files/{filename}`
    - **Spring Boot**: `@GetMapping("/files/{filename}")`과 같이 정의하고, 메서드 파라미터에 `@PathVariable`을 사용하여 값을 받는다.
        
    ```java
    @GetMapping("/products/{id}")
    public Product getProductById(@PathVariable int id) {
        // id 변수를 직접 사용
    }
    ```
    
- **라우트 제약 조건 (`:int` ↔ 타입 지정, `regex`)**:
    
    - **ASP.NET Core**: `{id:int}`
    - **Spring Boot**: `@PathVariable int id` 와 같이 파라미터 타입을 지정하는 것 자체가 강력한 제약 조건 역할을 한다. 정규 표현식 제약은 `@GetMapping` 어노테이션 안에 직접 추가할 수 있다. (`@GetMapping("/sales/{month:apr|jul|oct}")`)

이처럼 프레임워크마다 문법은 다르지만, '요청을 특정 핸들러와 연결한다'는 라우팅의 근본적인 철학은 동일하다.

